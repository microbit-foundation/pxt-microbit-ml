let getModelBlob: () => Buffer;

//% color=#2b64c3 weight=100 icon="\uf108" block="ML Runner" advanced=false
namespace mlrunner {
  // Start simulator code.
  type MlRunnerSimMessageType =
    | "register"
    | "init"
    | "data"
    | "request_data"
    | "trigger_action";

  interface MlRunnerSimMessage {
    type: MlRunnerSimMessageType;
    data?: any;
  }

  //% shim=TD_NOOP
  export function simulatorRegister(): void {
    const msg: MlRunnerSimMessage = {
      type: "register",
    };
    control.simmessages.onReceived("machineLearningPoc", handleMessage);
    simulatorSendMessage(msg);
  }

  export function simulatorSendData(): void {
    if (!Action.actions) {
      return;
    }
    const actionLabels = Action.actions.map((action) => ({
      name: action.eventLabel,
      value: action.eventValue,
    }));
    const msg: MlRunnerSimMessage = {
      type: "data",
      data: actionLabels,
    };
    simulatorSendMessage(msg);
  }

  //% shim=TD_NOOP
  function simulatorSendMessage(msg: MlRunnerSimMessage): void {
    const payload = Buffer.fromUTF8(JSON.stringify(msg));
    control.simmessages.send("machineLearningPoc", payload, false);
  }

  interface EventHandlers {
    [key: number]: () => void;
  }

  export const eventHandlers: EventHandlers = {};

  function simulateAction(eventValue: number) {
    const handler = eventHandlers[eventValue];
    if (handler) {
      handler();
    }
  }

  function handleMessage(buffer: Buffer) {
    const msg: MlRunnerSimMessage = JSON.parse(buffer.toString());
    switch (msg.type) {
      case "request_data": {
        simulatorSendData();
        break;
      }
      case "trigger_action": {
        simulateAction(msg.data.value);
      }
    }
  }

  //% shim=mlrunner::customOnEvent
  function customOnEvent(id: number, evid: number, handler: () => void) {
    // The sim probably won't respect the DropIfBusy flag
    control.onEvent(id, evid, handler, EventFlags.DropIfBusy);
  }
}
// End simulator code.

//% fixedInstances
//% blockNamespace=mlrunner
class MlEvent {
  eventValue: number;
  eventLabel: string;

  constructor(value: number, label: string) {
    this.eventValue = value;
    this.eventLabel = label;
  }

  /**
   * Run this code when the model detects the input label has been predicted.
   *
   * This automatically starts running the ML model in the background.
   * When the model predicts the indicated label, an event is raised to
   * trigger this handler.
   *
   * @param mlEvent The label event that triggers this code to run.
   * @param body The code to run when the model predicts the label.
   */
  //% blockId=mlrunner_on_ml_event
  //% block="on ML event $this"
  onEvent(body: () => void): void {
    mlrunner.eventHandlers[this.eventValue] = body;
    mlrunner.startRunning();
    mlrunner.customOnEvent(MlRunnerIds.MlRunnerInference, this.eventValue, body);
  }
}

namespace mlrunner {
  export namespace Action {
    //% fixedInstance
    export const None = new MlEvent(1, "None");
    export let actions = [None];
  }

  /**
   * TS shim for C++ function init(), which initialize the ML model with
   * an address to a model blob.
   *
   * @param modelBlob The model blob to initialize the ML model with.
   */
  //% blockId=mlrunner_init
  //% shim=mlrunner::init
  function initRunner(modelBlob: Buffer): void {
    return;
  }

  /**
   * Configure the ML model, start capturing accelerometer data, and run
   * the model in the background.
   */
  //% blockId=mlrunner_run_model_background
  //% block="run ML model in background"
  export function startRunning(): void {
    let modelBlob = hex``;
    // The model blob should be re-generated by the MakeCode extension
    if (typeof getModelBlob === "function") {
      modelBlob = getModelBlob() || hex``;
    }
    initRunner(modelBlob);
  }

  /**
   * Stop running the accelerometer data capturing and ML model in the
   * background.
   */
  //% blockId=mlrunner_stop_model_running
  //% block="stop running ML"
  //% shim=mlrunner::deinit
  export function stopRunning(): void {
    return;
  }

  /**
   * Check if the ML model is currently running in the background.
   */
  //% blockId=mlrunner_is_running
  //% block="is ML running"
  //% shim=mlrunner::isModelRunning
  export function isRunning(): boolean {
    return false;
  }

  simulatorRegister();
  simulatorSendData();
}
