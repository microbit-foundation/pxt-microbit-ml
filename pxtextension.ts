//% color=#2b64c3 weight=100 icon="\uf108" block="ML Runner" advanced=false
namespace mlrunner {
  // Start simulator code.
  type MlRunnerSimMessageType =
    | "register"
    | "init"
    | "data"
    | "request_data"
    | "trigger_action";

  interface MlRunnerSimMessage {
    type: MlRunnerSimMessageType;
    data?: any;
  }

  let simulatorRegistered = false;

  //% shim=TD_NOOP
  export function simulatorRegister(): void {
    if (!simulatorRegistered) {
      return;
    }
    const msg: MlRunnerSimMessage = {
      type: "register",
    };
    control.simmessages.onReceived("machineLearningPoc", handleMessage);
    simulatorSendMessage(msg);
    simulatorRegistered = true;
  }

  function simulatorSendData(): void {
    if (!actions) {
      return;
    }
    const actionLabels = actions.map((action, i) => ({
      name: action,
      value: i,
    }));
    const msg: MlRunnerSimMessage = {
      type: "data",
      data: actionLabels,
    };
    simulatorSendMessage(msg);
  }

  //% shim=TD_NOOP
  function simulatorSendMessage(msg: MlRunnerSimMessage): void {
    const payload = Buffer.fromUTF8(JSON.stringify(msg));
    control.simmessages.send("machineLearningPoc", payload, false);
  }

  interface EventHandlers {
    [key: number]: () => void;
  }

  export const eventHandlers: EventHandlers = {};

  function simulateAction(mlAction: number) {
    const handler = eventHandlers[mlAction];
    if (handler) {
      handler();
    }
  }

  function handleMessage(buffer: Buffer) {
    const msg: MlRunnerSimMessage = JSON.parse(buffer.toString());
    switch (msg.type) {
      case "request_data": {
        simulatorSendData();
        break;
      }
      case "trigger_action": {
        simulateAction(msg.data.value);
      }
    }
  }
  // End simulator code.

  /**
   * Run this code when the model detects the input label has been predicted.
   *
   * This automatically starts running the ML model in the background.
   * When the model predicts the indicated label, an event is raised to
   * trigger this handler.
   *
   * @param mlEvent The label event that triggers this code to run.
   * @param body The code to run when the model predicts the label.
   */
  //% blockId=mlrunner_on_ml_event
  //% block="on ML event %value"
  export function onMlEvent(mlEvent: MlRunnerLabels, body: () => void): void {
    eventHandlers[mlEvent] = body;
    simulatorRegister();
    startRunning();
    control.onEvent(MlRunnerIds.MlRunnerInference, mlEvent, body);
  }

  /**
   * TS shim for C++ function init(), which initialize the ML model with
   * an address to a model blob.
   *
   * @param modelBlob The model blob to initialize the ML model with.
   */
  //% blockId=mlrunner_init
  //% shim=mlrunner::init
  function initRunner(modelBlob: Buffer): void {
    return;
  }

  /**
   * Configure the ML model, start capturing accelerometer data, and run
   * the model in the background.
   */
  //% blockId=mlrunner_run_model_background
  //% block="run ML model in background"
  export function startRunning(): void {
    // The model blob should be re-generated by the MakeCode extension
    const modelBlob = getModelBlob() || hex``;
    initRunner(modelBlob);
  }

  /**
   * Stop running the accelerometer data capturing and ML model in the
   * background.
   */
  //% blockId=mlrunner_stop_model_running
  //% block="stop running ML"
  //% shim=mlrunner::deinit
  export function stopRunning(): void {
    return;
  }

  /**
   * Check if the ML model is currently running in the background.
   */
  //% blockId=mlrunner_is_running
  //% block="is ML running"
  //% shim=mlrunner::isModelRunning
  export function isRunning(): boolean {
    return false;
  }
}
