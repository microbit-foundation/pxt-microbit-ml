//% fixedInstances
//% blockNamespace=ml
class MlEvent {
  eventValue: number;
  eventLabel: string;
  lastDuration: number;
  onStopHandler: (duration: number) => void;

  constructor(value: number, label: string) {
    this.eventValue = value;
    this.eventLabel = label;
    this.lastDuration = 0;
  }
}

//% color=#2b64c3 weight=120 icon="\uf108" block="Machine Learning" advanced=false
namespace ml {
  //% blockNamespace=ml
  export namespace action {
    //% fixedInstance block="unknown"
    export const Unknown = new MlEvent(1, "unknown");
  }

  export let actions = [action.Unknown];
  let prevActionInstance: MlEvent = action.Unknown;
  let currentAction: MlEvent = action.Unknown;
  let lastActionTimestamp: number = 0;

  export function maybeUpdateActionStats(currentAction: MlEvent) {
    if (currentAction !== prevActionInstance) {
      let now = input.runningTime();
      prevActionInstance.lastDuration = now - lastActionTimestamp;

      if (prevActionInstance.onStopHandler) {
        prevActionInstance.onStopHandler(prevActionInstance.lastDuration);
      }

      lastActionTimestamp = now;
      prevActionInstance = currentAction;
    }
  }

  const deviceIsSim = control.deviceName().slice(0, 3) === "sim";

  /**
   * Run this code when the model detects the input label has been predicted.
   *
   * This automatically starts running the ML model in the background.
   * When the model predicts the indicated label, an event is raised to
   * trigger this handler.
   *
   * @param mlEvent The label event that triggers this code to run.
   * @param body The code to run when the model predicts the label.
   */
  //% blockId=mlrunner_on_ml_event
  //% block="on $mlClass detected"
  //% weight=30
  //% parts="v2"
  export function onDetected(mlClass: MlEvent, body: () => void): void {
    const wrappedBody = () => {
      if (prevActionInstance !== mlClass || deviceIsSim) {
        body();
      }
      if (prevActionInstance !== mlClass && deviceIsSim) {
        maybeUpdateActionStats(mlClass);
      }
    };
    if (!isRunning()) {
      startRunning();
    }
    mlRunnerCustomOnEvent(
      MlRunnerIds.MlRunnerInference,
      mlClass.eventValue,
      wrappedBody
    );
  }

  //% blockId=mlrunner_on_ml_event_stop
  //% block="on $mlClass ended after $duration (ms)"
  //% draggableParameters="reporter"
  //% parts="v2"
  //% weight=20
  export function onDetectedEnd(
    mlClass: MlEvent,
    body: (duration: number) => void
  ): void {
    if (!isRunning()) {
      startRunning();
    }
    mlClass.onStopHandler = body;
  }

  //% blockId=mlrunner_is_ml_event
  //% block="is $mlClass detected"
  //% weight=10
  //% parts="v2"
  export function isDetected(mlClass: MlEvent): boolean {
    if (!isRunning()) {
      startRunning();
      return false;
    }
    return mlClass.eventValue == currentActionId();
  }

  export let getModelBlob: () => Buffer;
  let simIsRunning = false;

  //% shim=mlrunner::customOnEvent
  function mlRunnerCustomOnEvent(
    id: number,
    evid: number,
    handler: () => void,
    flags?: number
  ) {
    // The sim probably won't respect the DropIfBusy flag
    control.onEvent(id, evid, handler, EventFlags.DropIfBusy);
  }

  /**
   * TS shim for C++ function init(), which initialize the ML model with
   * an address to a model blob.
   *
   * @param modelBlob The model blob to initialize the ML model with.
   */
  //% blockId=mlrunner_init
  //% shim=mlrunner::init
  function initRunner(modelBlob: Buffer): void {
    return;
  }

  /**
   * Configure the ML model, start capturing accelerometer data, and run
   * the model in the background.
   */
  function startRunning(): void {
    let modelBlob = hex``;
    // The model blob should be re-generated by the MakeCode extension
    if (typeof getModelBlob === "function") {
      modelBlob = getModelBlob() || hex``;
    }
    initRunner(modelBlob);
    simIsRunning = true;
  }

  /**
   * Check if the ML model is currently running in the background.
   */
  //% shim=mlrunner::isModelRunning
  function isRunning(): boolean {
    return simIsRunning;
  }

  //% shim=mlrunner::currentEventId
  function currentActionId(): number {
    return currentAction.eventValue;
  }

  // Start simulator code.
  type MlRunnerSimMessageType =
    | "register"
    | "init"
    | "data"
    | "request_data"
    | "trigger_action";

  interface MlRunnerSimMessage {
    type: MlRunnerSimMessageType;
    data?: any;
  }

  //% shim=TD_NOOP
  function simulatorRegister(): void {
    const msg: MlRunnerSimMessage = {
      type: "register",
    };
    control.simmessages.onReceived("machineLearningPoc", handleMessage);
    simulatorSendMessage(msg);
  }

  export function simulatorSendData(): void {
    if (!actions) {
      return;
    }
    const actionLabels = actions.map((action) => ({
      name: action.eventLabel,
      value: action.eventValue,
    }));
    const msg: MlRunnerSimMessage = {
      type: "data",
      data: actionLabels,
    };
    simulatorSendMessage(msg);
  }

  //% shim=TD_NOOP
  function simulatorSendMessage(msg: MlRunnerSimMessage): void {
    const payload = Buffer.fromUTF8(JSON.stringify(msg));
    control.simmessages.send("machineLearningPoc", payload, false);
  }

  function simulateAction(eventValue: number) {
    const simulatedAction = actions.find(
      (action) => action.eventValue === eventValue
    );
    currentAction = simulatedAction;
    // This will run the MLEvent onEvent block if it exists in the user's code.
    // Otherwise, control.onEvent in autogenerated.ts is fired.
    control.raiseEvent(MlRunnerIds.MlRunnerInference, eventValue);
  }

  function handleMessage(buffer: Buffer) {
    const msg: MlRunnerSimMessage = JSON.parse(buffer.toString());
    switch (msg.type) {
      case "request_data": {
        simulatorSendData();
        break;
      }
      case "trigger_action": {
        simulateAction(msg.data.value);
      }
    }
  }

  simulatorRegister();
  simulatorSendData();
  // End simulator code.
}
