let getModelBlob: () => Buffer;

//% shim=mlrunner::customOnEvent
function mlRunnerCustomOnEvent(
  id: number,
  evid: number,
  handler: () => void,
  flags?: number
) {
  // The sim probably won't respect the DropIfBusy flag
  control.onEvent(id, evid, handler, EventFlags.DropIfBusy);
}

//% fixedInstances
//% blockNamespace=mlrunner
class MlEvent {
  eventValue: number;
  eventLabel: string;
  lastDuration: number;
  onStopHandler: (duration: number) => void;

  constructor(value: number, label: string) {
    this.eventValue = value;
    this.eventLabel = label;
    this.lastDuration = 0;
  }

  /**
   * Run this code when the model detects the input label has been predicted.
   *
   * This automatically starts running the ML model in the background.
   * When the model predicts the indicated label, an event is raised to
   * trigger this handler.
   *
   * @param mlEvent The label event that triggers this code to run.
   * @param body The code to run when the model predicts the label.
   */
  //% blockId=mlrunner_on_ml_event
  //% block="on ML $this start"
  onEvent(body: () => void): void {
    const wrappedBody = () => {
      if (
        mlrunner.Action.prevActionInstance !== this ||
        mlrunner.deviceIsSim()
      ) {
        body();
      }
      if (
        mlrunner.Action.prevActionInstance !== this &&
        mlrunner.deviceIsSim()
      ) {
        mlrunner.Action.maybeUpdateActionStats(this);
      }
    };
    if (!mlrunner.isRunning()) {
      mlrunner.startRunning();
    }
    mlRunnerCustomOnEvent(
      MlRunnerIds.MlRunnerInference,
      this.eventValue,
      wrappedBody
    );
  }

  //% blockId=mlrunner_is_ml_event
  //% block="is ML $this action"
  isEvent(): boolean {
    if (!mlrunner.isRunning()) {
      mlrunner.startRunning();
      return false;
    }
    return this.eventValue == mlrunner.currentActionId();
  }

  //% blockId=mlrunner_on_ml_event_stop
  //% block="on ML $this stop $duration (ms)"
  //% draggableParameters="reporter"
  onStop(body: (duration: number) => void): void {
    this.onStopHandler = body;
  }
}

//% color=#2b64c3 weight=100 icon="\uf108" block="ML Runner" advanced=false
namespace mlrunner {
  export namespace Action {
    //% fixedInstance
    export const None = new MlEvent(1, "None");
    export let actions = [None];
    export let prevActionInstance: MlEvent = None;
    export let currentAction: MlEvent = None;
    export let lastActionTimestamp: number = 0;

    export function maybeUpdateActionStats(currentAction: MlEvent) {
      if (currentAction !== prevActionInstance) {
        let now = input.runningTime();
        prevActionInstance.lastDuration = now - lastActionTimestamp;

        if (prevActionInstance.onStopHandler) {
          prevActionInstance.onStopHandler(prevActionInstance.lastDuration);
        }

        lastActionTimestamp = now;
        prevActionInstance = currentAction;
      }
    }
  }

  let simIsRunning = false;

  export function deviceIsSim() {
    return control.deviceName().slice(0, 3) === "sim";
  }

  /**
   * TS shim for C++ function init(), which initialize the ML model with
   * an address to a model blob.
   *
   * @param modelBlob The model blob to initialize the ML model with.
   */
  //% blockId=mlrunner_init
  //% shim=mlrunner::init
  function initRunner(modelBlob: Buffer): void {
    return;
  }

  /**
   * Configure the ML model, start capturing accelerometer data, and run
   * the model in the background.
   */
  //% blockId=mlrunner_run_model_background
  //% block="run ML model in background"
  export function startRunning(): void {
    let modelBlob = hex``;
    // The model blob should be re-generated by the MakeCode extension
    if (typeof getModelBlob === "function") {
      modelBlob = getModelBlob() || hex``;
    }
    initRunner(modelBlob);
    simIsRunning = true;
  }

  /**
   * Stop running the accelerometer data capturing and ML model in the
   * background.
   */
  //% blockId=mlrunner_stop_model_running
  //% block="stop running ML"
  //% shim=mlrunner::deinit
  export function stopRunning(): void {
    simIsRunning = false;
  }

  /**
   * Check if the ML model is currently running in the background.
   */
  //% blockId=mlrunner_is_running
  //% block="is ML running"
  //% shim=mlrunner::isModelRunning
  export function isRunning(): boolean {
    return simIsRunning;
  }

  //% shim=mlrunner::currentEventId
  export function currentActionId(): number {
    return Action.currentAction.eventValue;
  }

  // Start simulator code.
  type MlRunnerSimMessageType =
    | "register"
    | "init"
    | "data"
    | "request_data"
    | "trigger_action";

  interface MlRunnerSimMessage {
    type: MlRunnerSimMessageType;
    data?: any;
  }

  //% shim=TD_NOOP
  export function simulatorRegister(): void {
    const msg: MlRunnerSimMessage = {
      type: "register",
    };
    control.simmessages.onReceived("machineLearningPoc", handleMessage);
    simulatorSendMessage(msg);
  }

  export function simulatorSendData(): void {
    if (!Action.actions) {
      return;
    }
    const actionLabels = Action.actions.map((action) => ({
      name: action.eventLabel,
      value: action.eventValue,
    }));
    const msg: MlRunnerSimMessage = {
      type: "data",
      data: actionLabels,
    };
    simulatorSendMessage(msg);
  }

  //% shim=TD_NOOP
  function simulatorSendMessage(msg: MlRunnerSimMessage): void {
    const payload = Buffer.fromUTF8(JSON.stringify(msg));
    control.simmessages.send("machineLearningPoc", payload, false);
  }

  function simulateAction(eventValue: number) {
    const simulatedAction = Action.actions.find(
      (action) => action.eventValue === eventValue
    );
    Action.currentAction = simulatedAction;
    // This will run the MLEvent onEvent block if it exists in the user's code.
    // Otherwise, control.onEvent in autogenerated.ts is fired.
    control.raiseEvent(MlRunnerIds.MlRunnerInference, eventValue);
  }

  function handleMessage(buffer: Buffer) {
    const msg: MlRunnerSimMessage = JSON.parse(buffer.toString());
    switch (msg.type) {
      case "request_data": {
        simulatorSendData();
        break;
      }
      case "trigger_action": {
        simulateAction(msg.data.value);
      }
    }
  }
  simulatorRegister();
  simulatorSendData();
  // End simulator code.
}
