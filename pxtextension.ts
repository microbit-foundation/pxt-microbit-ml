//% fixedInstances
//% blockNamespace=mlrunner
class MlEvent {
  eventValue: number;
  eventLabel: string;
  lastDuration: number;
  onStopHandler: (duration: number) => void;

  constructor(value: number, label: string) {
    this.eventValue = value;
    this.eventLabel = label;
    this.lastDuration = 0;
  }
}

//% blockNamespace=mlrunner
namespace mlactions {
  //% fixedInstance block="unknown"
  export const unknown = new MlEvent(1, "unknown");
  export let actions = [unknown];
  let prevActionInstance: MlEvent = unknown;
  export let currentAction: MlEvent = unknown;
  let lastActionTimestamp: number = 0;

  export function maybeUpdateActionStats(currentAction: MlEvent) {
    if (currentAction !== prevActionInstance) {
      let now = input.runningTime();
      prevActionInstance.lastDuration = now - lastActionTimestamp;

      if (prevActionInstance.onStopHandler) {
        prevActionInstance.onStopHandler(prevActionInstance.lastDuration);
      }

      lastActionTimestamp = now;
      prevActionInstance = currentAction;
    }
  }

  const deviceIsSim = control.deviceName().slice(0, 3) === "sim";

  /**
   * Run this code when the model detects the input label has been predicted.
   *
   * This automatically starts running the ML model in the background.
   * When the model predicts the indicated label, an event is raised to
   * trigger this handler.
   *
   * @param mlEvent The label event that triggers this code to run.
   * @param body The code to run when the model predicts the label.
   */
  //% blockId=mlrunner_on_ml_event
  //% block="on ML $action start"
  //% parts="v2"
  export function onStart(action: MlEvent, body: () => void): void {
    const wrappedBody = () => {
      if (prevActionInstance !== action || deviceIsSim) {
        body();
      }
      if (prevActionInstance !== action && deviceIsSim) {
        maybeUpdateActionStats(action);
      }
    };
    if (!mlrunner.isRunning()) {
      mlrunner.startRunning();
    }
    mlrunner.mlRunnerCustomOnEvent(
      MlRunnerIds.MlRunnerInference,
      action.eventValue,
      wrappedBody
    );
  }

  //% blockId=mlrunner_is_ml_event
  //% block="is ML $action action"
  //% parts="v2"
  export function isAction(action: MlEvent): boolean {
    if (!mlrunner.isRunning()) {
      mlrunner.startRunning();
      return false;
    }
    return action.eventValue == mlrunner.currentActionId();
  }

  //% blockId=mlrunner_on_ml_event_stop
  //% block="on ML $action stop $duration"
  //% draggableParameters="reporter"
  //% parts="v2"
  export function onStop(
    action: MlEvent,
    body: (duration: number) => void
  ): void {
    action.onStopHandler = body;
  }
}

//% color=#2b64c3 weight=100 icon="\uf108" block="ML Runner" advanced=false
namespace mlrunner {
  export let getModelBlob: () => Buffer;
  let simIsRunning = false;

  //% shim=mlrunner::customOnEvent
  export function mlRunnerCustomOnEvent(
    id: number,
    evid: number,
    handler: () => void,
    flags?: number
  ) {
    // The sim probably won't respect the DropIfBusy flag
    control.onEvent(id, evid, handler, EventFlags.DropIfBusy);
  }

  /**
   * TS shim for C++ function init(), which initialize the ML model with
   * an address to a model blob.
   *
   * @param modelBlob The model blob to initialize the ML model with.
   */
  //% blockId=mlrunner_init
  //% shim=mlrunner::init
  function initRunner(modelBlob: Buffer): void {
    return;
  }

  /**
   * Configure the ML model, start capturing accelerometer data, and run
   * the model in the background.
   */
  //% blockId=mlrunner_run_model_background
  //% block="run ML model in background"
  //% parts="v2"
  export function startRunning(): void {
    let modelBlob = hex``;
    // The model blob should be re-generated by the MakeCode extension
    if (typeof getModelBlob === "function") {
      modelBlob = getModelBlob() || hex``;
    }
    initRunner(modelBlob);
    simIsRunning = true;
  }

  /**
   * Stop running the accelerometer data capturing and ML model in the
   * background.
   */
  //% blockId=mlrunner_stop_model_running
  //% block="stop running ML"
  //% parts="v2"
  //% shim=mlrunner::deinit
  export function stopRunning(): void {
    simIsRunning = false;
  }

  /**
   * Check if the ML model is currently running in the background.
   */
  //% blockId=mlrunner_is_running
  //% block="is ML running"
  //% parts="v2"
  //% shim=mlrunner::isModelRunning
  export function isRunning(): boolean {
    return simIsRunning;
  }

  //% shim=mlrunner::currentEventId
  export function currentActionId(): number {
    return mlactions.currentAction.eventValue;
  }

  // Start simulator code.
  type MlRunnerSimMessageType =
    | "register"
    | "init"
    | "data"
    | "request_data"
    | "trigger_action";

  interface MlRunnerSimMessage {
    type: MlRunnerSimMessageType;
    data?: any;
  }

  //% shim=TD_NOOP
  function simulatorRegister(): void {
    const msg: MlRunnerSimMessage = {
      type: "register",
    };
    control.simmessages.onReceived("machineLearningPoc", handleMessage);
    simulatorSendMessage(msg);
  }

  export function simulatorSendData(): void {
    if (!mlactions.actions) {
      return;
    }
    const actionLabels = mlactions.actions.map((action) => ({
      name: action.eventLabel,
      value: action.eventValue,
    }));
    const msg: MlRunnerSimMessage = {
      type: "data",
      data: actionLabels,
    };
    simulatorSendMessage(msg);
  }

  //% shim=TD_NOOP
  function simulatorSendMessage(msg: MlRunnerSimMessage): void {
    const payload = Buffer.fromUTF8(JSON.stringify(msg));
    control.simmessages.send("machineLearningPoc", payload, false);
  }

  function simulateAction(eventValue: number) {
    const simulatedAction = mlactions.actions.find(
      (action) => action.eventValue === eventValue
    );
    mlactions.currentAction = simulatedAction;
    // This will run the MLEvent onEvent block if it exists in the user's code.
    // Otherwise, control.onEvent in autogenerated.ts is fired.
    control.raiseEvent(MlRunnerIds.MlRunnerInference, eventValue);
  }

  function handleMessage(buffer: Buffer) {
    const msg: MlRunnerSimMessage = JSON.parse(buffer.toString());
    switch (msg.type) {
      case "request_data": {
        simulatorSendData();
        break;
      }
      case "trigger_action": {
        simulateAction(msg.data.value);
      }
    }
  }

  simulatorRegister();
  simulatorSendData();
  // End simulator code.
}
